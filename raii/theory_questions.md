# RAII

## Теория

RAII (Resource Acquisition Is Initialization) - это фундаментальный паттерн 
проектирования в программировании, который  означает связывание жизненного цикла 
ресурса с временем жизни объекта. Это означает, что ресурс (например, память, 
файлы, сетевые соединения, блокировки мьютексов и т. д.) приобретается 
(инициализируется) в конструкторе объекта и освобождается (удаляется) в деструкторе 
объекта. Таким образом, время жизни ресурса автоматически управляется временем 
жизни объекта.  
Основная идея RAII заключается в том, чтобы избежать утечек ресурсов и обеспечить 
их корректное освобождение даже в случае исключений или других сложных ситуаций.

Почему RAII важен?
- Автоматическое освобождение ресурсов : В C++ программист несет ответственность за 
освобождение ресурсов. Если это делать вручную, легко допустить ошибки, такие как 
утечки памяти или двойное освобождение.
- Обработка исключений : RAII гарантирует, что ресурсы будут освобождены даже если 
выполнение программы прерывается исключением.
- Простота кода : С использованием RAII вам не нужно явно заботиться об 
освобождении ресурсов в разных точках программы. Все происходит автоматически.

Основные принципы RAII:
1) Правило владения. Объект должен четко определять, является ли он владельцем 
ресурса или просто ссылается на него.
Владелец ресурса отвечает за его освобождение.
2) Конструктор при создании объекта захватывает ресурс (например, выделяете память, 
открываете файл). Если конструктор завершается успешно, объект считается 
"владельцем" ресурса.
3) Деструктор. Когда объект уничтожается (выходит из области видимости или 
удаляется), его деструктор вызывается автоматически. В деструкторе вы 
"освобождаете" ресурс (например, освобождаете память, закрываете файл).
4) Если в конструкторе возникает исключение, объект не считается полностью 
созданым, и деструктор не вызывается. Однако если ресурс уже был захвачен до 
возникновения исключения, он должен быть корректно освобожден.

Пример использования динамической памяти:
```
class SimpleString
{
public:
  SimpleString(const char* str)
  {
    length = strlen(str); // вычисляем длину строки
    data = new char[length + 1]; // выделяем память под строку
    std::strcpy(data, str); // копируем данные
    data[length] = '\0'; // конец строки
  }

  ~SimpleString()
  {
    delete[] data; // освобождаем память.
  }
  //... остальная реализация

private:
  char* data = nullptr;
  size_t length = 0;
};
```

В современном C++ есть стандартные контейнеры и умные указатели, которые реализуют 
RAII, например:
- `std::vector`: Управляет динамической памятью для массивов.
- `std::unique_ptr`: Управляет единственным владельцем ресурса.
- `std::shared_ptr`: Управляет ресурсом с несколькими владельцами.
```
{
  //...
  std::unique_ptr<int> ptr = std::make_unique<int>(1); // выделяется память
  //...
}
// после выхода из скоупа, память освобождается
```

При реализации своих классов следует также помнить о правиле пяти (Rule of Five) и 
правиле трех (Rule of Three) - это важные концепции в C++, связанные с правильным 
управлением ресурсами и корректным поведением пользовательских классов при 
копировании и перемещении. Эти правила помогают избежать ошибок, связанных с 
дублированием или утечкой ресурсов.  
Правило трех гласит, что если определен деструктор, или конструктор копирования, или
оператор копирования, то следует определить все три.  
Для правила пяти добавляются конструктор перемещения и опреатор перемещения.  
Правило нуля (Rule of Zero) - это современное правило в C++, которое упрощает 
управление ресурсами в классах, избегая необходимости явно определять специальные 
члены класса, как в предудущих правилах. Это правило основано на использовании 
стандартных типов и умных указателей, таких как `std::unique_ptr` и 
`std::shared_ptr`, которые автоматически управляют ресурсами.

Преимущества RAII
- Безопасность: Гарантирует, что ресурсы будут освобождены, даже если программа 
завершается нештатно.
- Упрощение кода: Вы не пишете явные инструкции для освобождения ресурсов, что 
делает код более читабельным.
- Согласованность: Жизненный цикл ресурса четко связан с временем жизни объекта, 
что снижает вероятность ошибок.  

Ограничения RAII
- Передача владения: Если необходимо передать владение ресурсом между объектами, 
может потребоваться дополнительная логика (например, использование 
`std::unique_ptr` или `std::shared_ptr`).
- Сложные зависимости: В сложных системах возможны ситуации, когда несколько 
объектов зависят друг от друга, что может усложнить управление ресурсами.

Заключение:
RAII - это мощный инструмент для управления ресурсами, который может значительно 
упростить жизь программиста в написании безопасного и надежного кода. Основная идея 
заключается в том, чтобы связать управление ресурсами с временем жизни объектов, 
что делает программирование более простым и менее подверженным ошибкам. Стоит 
почаще использовать контейнеры из STL, так как они придерживаются идиомы RAII.

## Вопросы 

Выберете варианты для идиомы RAII?
1) Правило одной ответственности (Single Responsibility).
2) Правило трёх/пяти (Rule of Three/Five).
3) Правило ноля (Rule of Zero)
4) Принцип DRY (Don’t Repeat Yourself).
5) Все варианты верны.

Ответ: 2) и 3) Правило трёх/пяти (необходимо определить копирующие/перемещающие 
конструкторы и операторы, если класс владеет ресурсом) и правило ноля.

Какой из этих примеров НЕ использует RAII?
1) `std::unique_ptr<int> ptr(new int);`
2) `std::lock_guard<std::mutex> lock(mtx);`
3) `FILE* file = fopen("data.txt", "r");`
4) `std::ofstream file("log.txt");`

Ответ: 3) Ресурс управляется вручную.

Дан кусок кода
```
struct B;

struct A {
    std::shared_ptr<B> ptr;
};

struct B {
    std::shared_ptr<A> ptr;
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();

    a->ptr = b;
    b->ptr = a;
    return 0;
}
```
Будет ли в этом примере утечка памяти?
1) Да
2) Нет

Ответ: 1) Проблема с циклическими ссылками с использованием `std::shared_ptr`.
Решается использованием `std::weak_ptr` в одной из структур.