# Итераторы и инвалидация

## Теория

Шаблоны проектирования - это типовые решения общих проблем в проектировании ПО. 
Они дают рекомендации по решению определенных проблем. Важно упомянуть, что они помогают создавать гибкий и поддерживаемый код.
Итератор - это поведенческий шаблон проектирования, который предоставляет способ последовательного доступа к элементам объекта (например, контейнера как в C++),
не раскрывая его внутренней реализации.  
В библиотеке Standard Template Library контейнер - это объект предназначеный для хранения и управления коллекцией других объектов. Итераторы в STL являются важной концепцией используются для большинства контейнеров, таких как например 
`std::vector`, `std::list`, `std::unordered_map`, `std::map`, `std::set` и др.

Цели, которые решает данный паттерн:
- Стандартизировать интерфейс обхода для разных структур данных (списки, деревья, массивы).
- Инкапсулировать процесс обхода, отделив алгоритмы от данных.
- Поддержка обхода (например, обход в прямом и обратном порядке).

Как пример можно взять `std::vector<T>::iterator`, для доступа к элементам можно использовать операторы `*`, `->`, а для обхода по нему 
можно использовать инкрементирование `--` и декрементирование `++`.
Для обхода контейнера в цикле, как правило используется два подхода
1. Обычный обход: 
```
std::vector<int> vec = {12, 15, 21, 256, 78 };
for(auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << "; ";
}
```
2. Range-based, когда не требуется доступ к итератору:
```
std::vector<int> vec; // non empty vector
for (auto item : vec) {
    std::cout << item << "; ";
}
```

В STL итераторы можно разделить на такие типы:
- Input Iterator: Только чтение (например, для `std::istream`).
- Output Iterator: Только запись (например, для `std::ostream`).
- Forward Iterator: Чтение и запись, движение только вперёд (например, `std::forward_list`).
- Bidirectional Iterator: Движение вперёд и назад (например, `std::list`, `std::set`).
- Random Access Iterator: Произвольный доступ (например, `std::vector`, `std::deque`).
Важным преимуществом Random Access Iterator, является использование различных алгоритмов, например сортировки:
```
std::vector<int> vec;
std::sort(vec.begin(), vec.end());
```
Для Forward Iterator и Bidirectional Iterator, из-за отсутсвия произвольного доступа, предусмотрены встроенные методы для сортировки элементов:
```
std::list<int> list;
list.sort();
```

Инвалидация итераторов - ситуация, когда итератор перестаёт указывать на элемент контейнера из-за его изменения. Использование инвалидированного итератора ведёт к неопределённому поведению(undefined behavior). Поэтому стоит внимательно относится к модификации элементов контейнера.

В контейнерах можно выделить такие причины инвалидации:
- Вектор (`std::vector`):
  - При добавлении элементов, capacity становится равной size и нужно перелоцировать память.
  - Вставка и удаление элементов до текущей позиции итератора.  
  - Инвалидируются: все итераторы, ссылки и указатели.

- Дек (`std::deque`):
  - Вставка и удаление в начале или конце инвалидирует только итераторы на изменённую область.
  - Вставка в середину инвалидирует все итераторы.

- Хеш-контейнеры (`std::unordered_map`, `std::unordered_set`):   
  - При перехешировании инвалидируются все итераторы.

- Ассоциативные контейнеры (`std::set`, `std::map`):  
  - Инвалидируются итераторы на удалённые элементы.

- Список (`std::list`):  
  - Инвалидируются итераторы на удалённые элементы.


## Вопросы 

Какие операции поддерживают итераторы в C++?
  1) +, -, *, /
  2) &&, ||, !  
  3) ==, !=, =, ()
  4) ++, --, *, ->

Ответ: ++, --, *, ->.

Для какого типа итератора характерна  арифметика указателей?
  1) Forward Iterator
  2) Bidirectional Iterator
  3) Random Access Iterator
  4) Input Iterator

Ответ: Random Access Iterator.

Какие операции могут инвалидировать все итераторы `std::vector`?
  1) push_back
  2) erase
  3) insert
  4) begin

Ответ: push_back и insert.

При вставке в `std::deque` в начало, какие итераторы инвалидируются?
  1) Все
  2) Никакие
  3) Только итераторы на начало
  4) Зависит от реализации

Ответ: Только итераторы на начало.

