# Алгоритмическая сложность

## Теория

Алгоритмическая сложность - это математическая концепция, которая оценивает
эффективность алгоритма с точки зрения ресурсов, таких как время выполнения и объем
используемой памяти, в зависимости от размера входных данных. Она помогает сравнить
различные алгоритмы для решения одной и той же задачи, чтобы выбрать наиболее
оптимальный вариант.  
Для описания алгоритмической сложности используется нотация `Big O`, которая
используется для описания асимптотического поведения функций, особенно в контексте
анализа алгоритмов. Обозначается как `O(g(n))` используется для описания множества
функций `f(n)`, которые не растут быстрее чем `g(n)` при увеличении `n`. Это можно
записать следующим образом:
```
f(n)=O(g(n))
```
Основные алгоритмические сложности:
- O(1) - константное время. Например доступ элемента в массиве или `std::vector`
```
std::vector<int> vec = { 0, 1, 2 };
std::cout << "vec[1] = " << vec[1] << std::endl; 
```
- O(n) - линейное время (поиск в неупорядоченном массиве).
```
// return index or -1
int linearSearch(const std::vector<int>& vec, int target) 
{
    for (size_t i = 0; i < vec.size(); ++i) {
        if (vec.at(i) == target)
            return i;
    }
    return -1;
}
```
- O($n^2$) - квадратичное время (классический алгоритм сортировки пузырьком 
или вложенные циклы).
```
void bubbleSort(std::vector<int>& vec) 
{
    const size_t count = vec.size();

    for (size_t i = 0; i < count - 1; ++i) {
        for (size_t j = 0; j < count - i - 1; ++j) {
            if (vec[j] > vec[j + 1]) {
                std::swap(vec[j], vec[j + 1]);
            }
        }
    }
}
```
- O(log n) - логарифмическое время (бинарный поиск).
```
// return index or -1
int binarySearch(const std::vector<int>& vec, const int target)
{
    int left = 0;
    int right = vec.size() - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (vec[mid] == target) {
            return mid;
        } else if (vec[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```
- O(n log n) - алгоритмы сортировки. Например алгоритм быстрой сортировки в среднем
и лучшем имеет такую сложность, в худшем, когда массив уже отсортирован будет
квадратичная.
```
void quickSort(std::vector<int>& vec, int left, int right) {
    if (left >= right) 
        return;

    int pivot = vec[(left + right) / 2];
    int i = left, j = right;
    while (i <= j) {
        while (vec[i] < pivot) 
            i++;
        while (vec[j] > pivot)
            j--;
        
        if (i <= j) {
            std::swap(vec[i], vec[j]);
            i++;
            j--;
        }
    }

    if (left < j) 
        quickSort(vec, left, j);
    if (i < right) 
        quickSort(vec, i, right);
}
```
- O(n!) - факториальное время. Например задача о коммивояжёре.
Для n городов нужно проверить все возможные маршруты, а их количество равно 
(n−1)!.  
Нужно старательно избагать применения алгоритмов с плохой сложностью, таких как 
$n^2$ и n!.  

В библиотеки STL контейнеры основаны на популярных структурах данных и имеют
разную алгоритмическую сложность для различных действий над ними. Рассмотрим 
основные и наиболее часто используемые из них:

1. Вектор `std::vector` - представляет из себя динамический массив расположенный
непрерывно в памяти. Сложность по основным операциям:
    - Доступ к элементы: O(n).
    - Добавление элемента в конец: амортизированная константа O(1). Такая сложность
    появляется, когда емкость становится равной размеру вектора, то приходится
    выделить новй объем памяти и перенести туда все элементы и после добавить новый
    и сложность становится линейной.
    - Удаление из конца: O(1)
    - Вставка или удаление в середине: O(n). Требуется сдвиг всех элементов после
    позиции вставки/удаления.  

2. Список `std::list` - двусвязный список. Сложность по основным операциям:
    - Доступ к элементу : O(n). Не поддерживает случайный доступ,
    необходимо перебрать элементы.
    - Добавление/удаление в начало или конец : O(1)
    - Вставка/удаление в середину : O(1), если известен итератор на позицию.  

3. Дек `std::deque` - двусторонняя очередь, которая позволяет эффективно добавлять
или удалять элементы с обоих концов. 
    - Доступ к элементу : O(1). Поддерживает индексированный доступ.
    - Добавление/удаление в начало или конец : O(1)
    - Вставка или удаление в середине : O(n). Требуется сдвиг элементо

4. Стеки `std::stack` и очереди `std::queue`. Эти структуры данных являются адапторами контейнеров и обычно основаны на `std::deque`.
    - Добавление/удаление элементов: O(1)
    - Доступ к элементу: O(1) для вершины стека или начала очереди.

5. Множества `std::set` и словарь `std::map`. Реализованы как красно-черные
деревья, хотя стандарт это не регламентирует.
    - Поиск элемента : O(log n)
    - Вставка/удаление : O(log n)

6. `std::unordered_set` и `std::unordered_map`. Основаны на хеш-таблицах.
    - Поиск элемента : Среднее время O(1), в худшем случае O(n) при коллизиях.
    - Вставка/удаление : Среднее время O(1), в худшем случае O(n).  

Также библиотека STL предоставляет основные алгоритмы для работы с некоторыми 
контейнерами таких как сортировка, поиск, слияние.  
- Сортировка `(std::sort)`: O(n log n) в среднем и в худшем случае.
- Поиск `(std::find)`: O(n)
- Бинарный поиск `(std::binary_search)`: O(log n), но требует предварительной
сортировки.
- Слияние `(std::merge)`: O(n + m), где n и m — размеры двух последовательностей.  

Стоит помнить, что не все алгоритмы можно использовать на контейнерах STL. Например
на `std::list` нельзя использовать `std::sort`, так как требует произвольного
доступа к элементам (Random Access Iterators), но он имеет строенный метод для
сортировки.   

Из общих рекомендаций по использованию выбора контейнера или алгоритма в STL
зависит от ваших задач.
- Для быстрого доступа по индексу используйте `std::vector`.
- Для частых вставок/удалений в середине списка используйте `std::list`.
- Для поиска элементов используйте `std::set` или `std::unordered_set`, в
зависимости от необходимости поддерживать порядок.
- Для работы с ключами и значениями выбирайте между 
`std::map` и `std::unordered_map`.

## Вопросы

Можно ли удалить первый элемент из `std::vector` за констатное время?
1) Да.
2) Нет.

Ответ: Можно, поменяв первый элемент с последним и применив `pop_back`, но
это нарушает порядок элементов.

Мы знаем что в `std::unordered_map` в худшем случае поиск элемента будет O(n).
В каких случаях это может произойти?
1) В контейнере находится очень много элементов.
2) Многие ключи имеют одинаковые значения хеша.
3) Все элементы оказываются в одной корзине, образуя список или дерево внутри
этой корзины.
4) Если в качестве ключей используется `std::string`.

Ответ: 2 и 3.

Дан такой кусок кода:
```
std::vector<int> vec = { 1, 2, 3, 4, 5 };

for (size_t i = 0; i < vec.size(); ++i) {
    vec[i] *= 5;
}

for (size_t i = 0; i < vec.size(); ++i) {
    vec[i] += 3;
}

for (size_t i = 0; i < vec.size(); ++i) {
    std::cout << vec[i] % 2 << " ";
}
```
Какая будет у него алгоритмическая сложность?

1) O(1)
2) O(log n)
3) O(n)
4) O($n^3$)

Ответ: 3. Все три цикла выполняются последовательно, и все они выполняются имеют
линейную сложность.
