# Связь с моделью памяти и управление памятью в контейнерах

## Теория

Сначала нужно коротко напомнить как устроена работа с памятью в C++. Она включает
несколько основных аспектов: управление стеком, кучей (heap), глобальной
памятью и статической памятью.  

- Стек:  
Память используется для хранения локальных переменных функций и управления
вызовами функций в скоупе. 
```
void someMethod()
{ // Начало скоупа
  int count = 0; // Переменная count находится на стек
} // Конец скоупа. Переменная count уничтожается и память освобождается.
```
- Куча:  
Динамическая область памяти, где программист может явно выделять и освобождать
память во время выполнения программы. Требует ручного управления памятью:
```
int* count = new int(1); // Выделение памяти
delete count; // Освобождение памяти.
```
- Глобальная/Статическая память:  
Используется для глобальных и статических переменных, которые существуют в течение 
всего времени выполнения программы.
```
int count = 3; // Глобальная переменная
// ...
int main()
{
  count = 5; // Обращение к переменной
}
```
- Память для регистров и кэша:  
Управляемая компилятором и процессором, она оптимизирует доступ к данным.

Также следует упомянуть, в STL, начиная с C++11 для удобства работы с памятью 
предоставляются умные указатели `std::unique_ptr`, `std::shared_ptr` и
`std::weak_ptr`.  

Аллокаторы - это ключевой механизм управления памятью в STL. Они отвечают за 
выделение и освобождение памяти для элементов контейнера. По умолчанию STL 
использует стандартный аллокатор (`std::allocator`), который работает с кучей через 
`operator new` и `operator delete`.  
При написании собсвенных аллокаторов следует помнить об исключениях, которые могу 
вылететь при выделении памяти.

Основные задачи аллокаторов:  
- Выделение памяти : Аллокатор выделяет блок памяти для хранения элементов.
- Освобождение памяти : После удаления элементов или уничтожения контейнера
аллокатор освобождает память.
- Конструирование и разрушение объектов : Аллокатор вызывает конструкторы и 
деструкторы для объектов, размещенных в выделенной памяти.  

Каждый контейнер в STL имеет свою внутреннюю структуру данных и стратегию 
управления памятью. Рассмотрим основные контейнеры:  
1) `std::vector`
  - Хранилище: представляет из себя непрерывный блок памяти.
  - Управление памятью: при добавлении элементов вектор увеличивает свой размер 
  (обычно удваивает текущую емкость). Это минимизирует количество перераспределений 
  памяти.
```
std::vector<int> vec;
vec.reserve(100); // Резервируем память на сто элементов
for (int i = 0; i < 60; ++i) {
  vec.push_back(i); // Вставка 60 элементов не вызовет релокацию памяти для вектора
}
```
2) `std::list`
  - Хранилище: двусвязный список, где каждый элемент содержит указатели на
  предыдущий и следующий элементы.
  - Управление памятью: каждый элемент выделяется отдельно в куче. Это позволяет
  легко добавлять и удалять элементы без перераспределения памяти.

3) `std::deque`
  - Хранилище: блоки фиксированного размера, связанные между собой.
  - Управление памятью: эффективно поддерживает добавление элементов как в начало, 
  так и в конец. При необходимости создаются новые блоки.
```
std::deque<std::string> dq;
dq.push_back("end"); // вставка элемента в конец
dq.push_front("start"); // вставка элемента в начало
```
4) `std::map`
  - Хранилище: хранит элементы в виде пар (ключ, значение) в отсортированном 
  порядке по ключу. По умолчанию он реализован как сбалансированное дерево поиска 
  (обычно красно-черное дерево).
  - Управление памятью: каждый элемент занимает больше памяти, чем просто пара 
  (ключ, значение). Это связано с необходимостью хранить дополнительные указатели 
  для поддержания структуры дерева.
5) `std::unordered_map`
  - Хранилище: каждый элемент хранится в виде пары (ключ, значение).
  Элементы размещаются в корзинах (buckets), которые формируют массив.
  - Управление памятью: выделяется память для массива корзин при создании. Размер 
  этого массива зависит от числа элементов и коэффициента загрузки (load factor). 
  Если количество элементов превышает допустимый порог, массив корзин 
  перераспределяется (рехеширование), что означает создание нового массива большего 
  размера и перенос всех элементов в новые корзины. 
```
std::unordered<int, std::string> address_book;
address_book.reserve(50); // Резервирование 50 элементов
address_book.insert(79990001122, "John");
```

Управление памятью в контейнерах STL - это сложный, но важный аспект 
программирования на C++. Понимание того, как работают аллокаторы, как организованы 
внутренние структуры данных и как оптимизировать использование памяти, позволяет 
создавать эффективные и надежные программы.

Основные выводы:  
- STL контейнеры используют кучу для хранения элементов.
- Аллокаторы обеспечивают гибкость в управлении памятью.
- Выбор контейнера зависит от требований к производительности и типу данных.
- Оптимизация памяти (например, через reserve) может значительно улучшить 
производительность.

## Вопросы 

Какой контейнер не требует переаллокации памяти при вставке элементов?
1) std::vector
2) std::string
3) std::list
4) std::deque

Ответ: 3) std::list (память выделяется только для нового узла).

Что произойдет, если в контейнере `std::unordered_map` вызвать метод `insert` 
несколько раз с одинаковыми ключами?
1) Все значения будут добавлены в контейнер.
2) Только первое значение будет добавлено, последующие игнорируются.
3) Будет выброшено исключение.
4) Все значения будут добавлены, но только последнее значение будет доступно по 
ключу.

Ответ: 4)

Дан такой кусок кода
```
std::unique_ptr<int> counter1 = std::make_unique<int>(1);
std::unique_ptr<int> counter2 = counter1;
```
Скомпилируется ли он?
1) Да
2) Нет

Ответ: 2) `std::unique_ptr` нельзя скопировать.
